{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "# Programowanie obiektowe 2 - decydujące starcie"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zacznijmy od krótkiego, hasłowego, niepełnego podsumowania pierwszej części materiałów.\n",
    "\n",
    "### W poprzednim odcinku ...\n",
    "1. Atrybuty\n",
    "- Można dodać nowy atrybut do już utworzonego obiektu - Rada: nie robimy tego. Inicjalizujmy atrybuty (obiektowe) w metodzie `__init__`\n",
    "2. Metody\n",
    "- przypomnijmy, w Pythonie funkcje to obiekty pierwszej klasy\n",
    "_(tworzone w czasie wykonania, przypisywane do zmiennej lub elementu w strukturze danych, przekazywane jako argument do funkcji, zwracane jako wynik funkcji)_\n",
    "-- metody w klasach to po prostu atrybuty, których wartościami są funkcje\n",
    "-- funkcja (z parametrem będącym obiektem) i metoda z perspektywy Pythona wyglądają tak samo\n",
    "-- Rada: w prostych interfejsach akceptuj funkcje zamiast klas (zob też 1.2.1.)\n",
    "- bound method - metoda powiązana z obiektem\n",
    "- w Pythonie nie możemy przeciążać metod\n",
    "3. Porównywanie `is` vs `==`\n",
    "4. Widoczność\n",
    "- dziurawa hermetyzacja - zgodnie z mottem \"jesteśmy dorośli\" - język nie uniemożliwi nam dostępu nawet do `__atrybutów`\n",
    "5. Konstruktory\n",
    "- Rada: korzystaj z `super().__init__()` zamiast `MojaNadklasa.__init__()`, aby w przypadku wielodziedziczenia mieć pewność, że metody nadklas wykonają się tylko raz (zob. też 2)\n",
    "\n",
    "Zaraz, zaraz, jak to wielodziedziczenia ???"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "### Polecana literatura\n",
    "1. Zaawansowany Python (Fluent Python), Ramalho\n",
    "2. Efektywny Python, Slatkin\n",
    "3. Python Distilled, Beazley"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Tymczasem w niniejszych materiałach zmierzymy się z:\n",
    "### Zagadnienia\n",
    "1. Pythoniczność obiektów\n",
    "2. Wielokrotne dziedziczenie\n",
    "3. Method resolution order - MRO\n",
    "4. Klasy domieszki\n",
    "5. Różne uwagi\n",
    "6. Metaklasy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "## 1. Pythoniczność obiektów\n",
    "\n",
    "Istnieje kilka nadrzędnych zasad pisania dobrego oprogramowania, które można debugować, testować i rozszerzać. Wzorce projektowe znane z innych języków możesz oczywiście zastosować w Pythonie. Jednak wiele z nich rozwiązuje problemy wynikające ze ścisłej natury systemu statycznych typów C++ lub Javy. W Pythonie mogą być przesadne lub niepotrzebne. Ogólna zasada pozostaje taka sama, sposób programowania może być inny."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "### 1.1 Uniwersalność obiektów poprzez definiowanie metod dunder"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Pythoniczność - typy definiowane przez użytkownika mogą działać tak naturalnie jak typy wbudowane. Możemy osiągnąć to bez dziedziczenia w duchu kaczego typowania.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 1.1.1. Film v.0\n",
    "Zobaczmy przykład z klasą film i znanymi już `__repr__`, `__str__`, `__eq__`, `__lt__`. Przyjrzyjmy się `__iter__` i `__len__`. Dzięki `__iter__` możemy definiować jak iterować po naszym obiekcie. Możemy potraktować nasze atrybuty jako kolejne elementy, z których możemy zrobić krotkę..."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:25:56.255459Z",
     "start_time": "2025-01-13T20:25:56.240828Z"
    }
   },
   "source": [
    "class Film:\n",
    "    def __init__(self, tytuł, ocena, długość):\n",
    "        self.tytuł = tytuł\n",
    "        self.ocena = ocena\n",
    "        self.długość = długość\n",
    "\n",
    "    def __repr__(self):\n",
    "        return \"Film:\"+str(self)\n",
    "\n",
    "    def __str__(self):\n",
    "        return str(tuple(self))         # zdefiniujemy teraz __iter__ aby można było robić tuple(Film)\n",
    "\n",
    "    def __iter__(self):\n",
    "        return iter((self.tytuł, self.ocena, self.długość))             # tu podajemy nasz iterator\n",
    "        # wygenerowany za pomocą funkcji wbudowanej iter() zob https://docs.python.org/3/library/functions.html#iter\n",
    "        # return (i for i in (self.tytuł, self.ocena, self.długość))    # lub generator\n",
    "        # który znamy z poprzednich zajęć\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        return tuple(self) == tuple(other)\n",
    "\n",
    "    def __len__(self):                  # Tu uwaga: mamy iter, czyli Film jest trochę sekwencją, a len nie podaje długości tej sekwencji!\n",
    "        return self.długość\n",
    "\n",
    "    def __lt__(self, other):\n",
    "        if self.ocena == other.ocena:\n",
    "            return len(self) < len(other)\n",
    "        return self.ocena < other.ocena\n"
   ],
   "outputs": [],
   "execution_count": 2
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:25:56.893338Z",
     "start_time": "2025-01-13T20:25:56.889953Z"
    }
   },
   "source": [
    "japoński = Film(\"Ikiru\", 9, 143)\n",
    "amerykański = Film(\"Lot nad kukułczym gniazdem\", 10, 133)\n",
    "polski = Film(\"Przypadek\", 10, 114)"
   ],
   "outputs": [],
   "execution_count": 3
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Dzięki `__repr__` mamy eleganckie wypisywanie, przydatne np. w debuggowaniu."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:26:00.482366Z",
     "start_time": "2025-01-13T20:26:00.476964Z"
    }
   },
   "source": [
    "polski"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Film:('Przypadek', 10, 114)"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 4
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zdefiniowanie `__len__` sprawia, że każdy będzie mógł wywołać `len(obj)`. Zauważmy, że będziemy traktować Film, jako obiekt iterowalny, zatem intuicyjnie po `len` spodziewalibyśmy się liczby elementów, po których iterujemy. Niech stanowi to przestrogę, przy korzystaniu z importowanych klas."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:26:04.334412Z",
     "start_time": "2025-01-13T20:26:04.331805Z"
    }
   },
   "source": [
    "len(amerykański)  # mamy rozmiar obiektu - długość filmu"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "133"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 5
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Funkcje `__iter__` sprawiają, że obiekt traktujemy podobnie jak inne w Pythonie..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Możemy po nim iterować"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:26:12.986264Z",
     "start_time": "2025-01-13T20:26:12.983969Z"
    }
   },
   "source": [
    "for i in amerykański: # dzięki __iter__ możemy iterować po obiekcie\n",
    "    print(i)"
   ],
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Lot nad kukułczym gniazdem\n",
      "10\n",
      "133\n"
     ]
    }
   ],
   "execution_count": 6
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Konwertować do standardowych kolekcji"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:15:21.118598400Z",
     "start_time": "2023-11-27T01:15:21.026655200Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "('Ikiru', 9, 143)"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tuple(japoński)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:15:22.141793700Z",
     "start_time": "2023-11-27T01:15:22.077931200Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['Przypadek', 10, 114]"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(polski)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:15:23.753813600Z",
     "start_time": "2023-11-27T01:15:23.716911600Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{10, 133, 'Lot nad kukułczym gniazdem'}"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "set(amerykański)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Możemy też nasze obiekty przechowywać w standardowych kolekcjach, a dzięki `__lt__` sortować te kolekcje.\n",
    "Bez `__lt__` pojawi się `TypeError: '<' not supported between instances of 'Film' and 'Film'`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:15:38.914569100Z",
     "start_time": "2023-11-27T01:15:38.877668400Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[Film:('Ikiru', 9, 143),\n",
       " Film:('Przypadek', 10, 114),\n",
       " Film:('Lot nad kukułczym gniazdem', 10, 133)]"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "l = [japoński, amerykański, polski]\n",
    "l.sort()    # dzięki __lt__ możemy sortować nasze obiekty\n",
    "l"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zauważmy, że nie mamy jeszcze wszystkich typowych możliwości"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:15:45.590817500Z",
     "start_time": "2023-11-27T01:15:45.522001200Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "unhashable type: 'Film'",
     "output_type": "error",
     "traceback": [
      "\u001B[0;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[0;31mTypeError\u001B[0m                                 Traceback (most recent call last)",
      "Cell \u001B[0;32mIn[10], line 1\u001B[0m\n\u001B[0;32m----> 1\u001B[0m \u001B[38;5;28;43mset\u001B[39;49m\u001B[43m(\u001B[49m\u001B[43ml\u001B[49m\u001B[43m)\u001B[49m\n",
      "\u001B[0;31mTypeError\u001B[0m: unhashable type: 'Film'"
     ]
    }
   ],
   "source": [
    "set(l)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 1.1.2. Film v.1\n",
    "Aby utworzyć zbiór filmów, obiekt Film musi być hashowalny. Musimy zaimplementować metodę `__hash__` (`__eq__` już mamy) i dopilnować, że instancje Film są niezmienne. Skorzystamy zatem z dekoratora `@property`. Metoda getter jest nazwana jak publiczna właściwość, którą eksponuje. Zatem każda metoda korzystająca z `self.atrybut` (jak np `__iter__`) może pozostać tak jak jest."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:28:12.703325Z",
     "start_time": "2025-01-13T20:28:12.697730Z"
    }
   },
   "source": [
    "class Film:\n",
    "    def __init__(self, tytuł, ocena, długość):\n",
    "        self.__tytuł = tytuł\n",
    "        self.__ocena = ocena\n",
    "        self.__długość = długość\n",
    "\n",
    "    @property                   # dodaję property dla atrybutów, które teraz są __atrybutami\n",
    "    def tytuł(self):\n",
    "        return self.__tytuł\n",
    "\n",
    "    @property\n",
    "    def ocena(self):\n",
    "        return self.__ocena\n",
    "\n",
    "    @ property\n",
    "    def długość(self):\n",
    "        return self.__długość\n",
    "\n",
    "    def __hash__(self):         # dodaję metodę dunder hash\n",
    "        return hash(tuple(self))\n",
    "\n",
    "    # RESZTA PONIŻEJ POZOSTAJE BEZ ZMIAN\n",
    "    def __repr__(self):\n",
    "        return \"Film:\"+str(self)\n",
    "\n",
    "    def __str__(self):\n",
    "        return str(tuple(self))\n",
    "\n",
    "    def __iter__(self):\n",
    "        return iter((self.tytuł, self.ocena, self.długość))\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        return tuple(self) == tuple(other)\n",
    "\n",
    "    def __len__(self):\n",
    "        return self.długość\n",
    "\n",
    "    def __lt__(self, other):\n",
    "        if self.ocena == other.ocena:\n",
    "            return len(self) < len(other)\n",
    "        return self.ocena < other.ocena"
   ],
   "outputs": [],
   "execution_count": 9
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:28:13.516165Z",
     "start_time": "2025-01-13T20:28:13.510489Z"
    }
   },
   "source": [
    "japoński = Film(\"Ikiru\", 9, 143)\n",
    "amerykański = Film(\"Lot nad kukułczym gniazdem\", 10, 133)\n",
    "polski = Film(\"Przypadek\", 10, 114)\n",
    "l = [japoński, amerykański, polski]\n",
    "l.sort()    # dzięki __lt__ możemy sortować nasze obiekty\n",
    "l"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[Film:('Ikiru', 9, 143),\n",
       " Film:('Przypadek', 10, 114),\n",
       " Film:('Lot nad kukułczym gniazdem', 10, 133)]"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 10
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:28:14.659356Z",
     "start_time": "2025-01-13T20:28:14.656522Z"
    }
   },
   "source": [
    "set(l)"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{Film:('Ikiru', 9, 143),\n",
       " Film:('Przypadek', 10, 114),\n",
       " Film:('Lot nad kukułczym gniazdem', 10, 133)}"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 11
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zatem czy mamy już wszystko? Zobaczmy może, czy nasz Film można traktować bezpośrednio jako sekwencję."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:28:22.786654Z",
     "start_time": "2025-01-13T20:28:22.783552Z"
    }
   },
   "source": [
    "l = list(polski)\n",
    "l[1]"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 12
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:28:23.610915Z",
     "start_time": "2025-01-13T20:28:23.601175Z"
    }
   },
   "source": [
    "polski[1]"
   ],
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "'Film' object is not subscriptable",
     "output_type": "error",
     "traceback": [
      "\u001B[0;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[0;31mTypeError\u001B[0m                                 Traceback (most recent call last)",
      "Cell \u001B[0;32mIn[13], line 1\u001B[0m\n\u001B[0;32m----> 1\u001B[0m polski[\u001B[38;5;241m1\u001B[39m]\n",
      "\u001B[0;31mTypeError\u001B[0m: 'Film' object is not subscriptable"
     ]
    }
   ],
   "execution_count": 13
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 1.1.3. Film v.2\n",
    "Aby mieć dostęp do elementów w naszej klasie przez `[indeks]`, musimy zdefiniować metodę `__getitem__`"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:28:35.085169Z",
     "start_time": "2025-01-13T20:28:35.080512Z"
    }
   },
   "source": [
    "class Film:\n",
    "    def __init__(self, tytuł, ocena, długość):\n",
    "        self.__tytuł = tytuł\n",
    "        self.__ocena = ocena\n",
    "        self.__długość = długość\n",
    "\n",
    "    def __getitem__(self, index):\n",
    "        return tuple(self)[index]\n",
    "\n",
    "    # RESZTA PONIŻEJ POZOSTAJE BEZ ZMIAN\n",
    "\n",
    "    @property\n",
    "    def tytuł(self):\n",
    "        return self.__tytuł\n",
    "\n",
    "    @property\n",
    "    def ocena(self):\n",
    "        return self.__ocena\n",
    "\n",
    "    @ property\n",
    "    def długość(self):\n",
    "        return self.__długość\n",
    "\n",
    "    def __hash__(self):\n",
    "        return hash(tuple(self))\n",
    "\n",
    "    def __repr__(self):\n",
    "        return \"Film:\"+str(self)\n",
    "\n",
    "    def __str__(self):\n",
    "        return str(tuple(self))\n",
    "\n",
    "    def __iter__(self):\n",
    "        return iter((self.tytuł, self.ocena, self.długość))\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        return tuple(self) == tuple(other)\n",
    "\n",
    "    def __len__(self):\n",
    "        return self.długość\n",
    "\n",
    "    def __lt__(self, other):\n",
    "        if self.ocena == other.ocena:\n",
    "            return len(self) < len(other)\n",
    "        return self.ocena < other.ocena"
   ],
   "outputs": [],
   "execution_count": 14
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:28:35.596322Z",
     "start_time": "2025-01-13T20:28:35.593600Z"
    }
   },
   "source": [
    "polski = Film(\"Przypadek\", 10, 114)\n",
    "polski[1]"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 15
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:28:36.663001Z",
     "start_time": "2025-01-13T20:28:36.660476Z"
    }
   },
   "source": [
    "polski[1:]"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(10, 114)"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 16
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zauważmy, że działa nawet slicing. Nasza implementacja sprawia jednak, że zwracana jest krotka, a nie obiekt Film..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### Podsumowując\n",
    "Python do znajdowania atrybutów obiektów używa wiązań dynamicznych, które umożliwiają pracę z instancjami bez względu na ich typ. `Obj.name` zadziała na dowolnym `obj`, który ma `name` (kacze typowanie). Programiści Pythona często zamiast dziedziczyć po jakimś obiekcie, tworzą nowy niepowiązany obiekt, który wygląda i zachowuje się jak on. Tak było w omawianym przez nas przykładzie -  nasz Film byl iterowalny, ale nie dziedziczył po żadnej klasie `Iterable`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "### 1.2 Dziedziczenie"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 1.2.1. Unikanie dziedziczenia - zamiast klas zastosuj funkcje\n",
    "szczególnie w prostych przypadkach z jedną metodą. Rozważmy przypadek, gdzie różni widzowie zapamiętują różne aspekty filmu."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:29:20.367832Z",
     "start_time": "2025-01-13T20:29:20.363251Z"
    }
   },
   "source": [
    "class Widz:\n",
    "    def opowiedz(self, film):\n",
    "        ciekawostki = []\n",
    "        for el in film:\n",
    "            if self.zapamiętuję(el):\n",
    "                ciekawostki.append(el)\n",
    "        return ciekawostki\n",
    "\n",
    "    def zapamiętuję(self, el):\n",
    "        return True\n",
    "\n",
    "class WidzMatematyk(Widz):              # WidzMatematyk dziedziczy po Widz\n",
    "    def zapamiętuję(self, el):\n",
    "        return type(el) == int          # zapamiętuje tylko liczbowe atrybuty\n",
    "\n",
    "widz = WidzMatematyk()\n",
    "opis = widz.opowiedz(japoński)\n",
    "opis"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[9, 143]"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 17
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Tymczasem rozwiązanie z funkcjami w takim przypadku jest prostsze i równie elastyczne."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:30:29.675085Z",
     "start_time": "2025-01-13T20:30:29.671470Z"
    }
   },
   "source": [
    "def opowiedz(film, zapamiętuję):\n",
    "    ciekawostki = []\n",
    "    for el in film:\n",
    "        if zapamiętuję(el):\n",
    "           ciekawostki.append(el)\n",
    "    return ciekawostki\n",
    "\n",
    "def zapamiętuję_mat(el):                        # jedna polimorficzna funkcja z przykładu wyżej\n",
    "    return type(el) == int\n",
    "\n",
    "opis = opowiedz(japoński, zapamiętuję_mat)      # wybraną funkcję przekazuję jako argument\n",
    "opis"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[9, 143]"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 18
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Podobnie dla tzw. zaczepów - metoda `sort()` pobiera opcjonalny argument `key`, któremu możemy przypisać funkcję (zob. materiały Python funkcyjny) `sort(key=len)`. W innych językach można oczekiwać, że zaczepy będą zdefiniowane przez klasę abstrakcyjną."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 1.2.2. Unikanie dziedziczenia przez stosowanie kompozycji\n",
    "Załóżmy, że naszym zadaniem jest implementacja zbioru filmów do obejrzenia. W zamierzchłych czasach były one na nośnikach dvd i odkładając jeden film na drugi ... tworzył się stos. Bardzo szybko naszą implementację możemy otrzymać dziedzicząc po list."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:21:53.890341Z",
     "start_time": "2023-11-27T01:21:53.837296500Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class KolejkaOglądania(list):   # nasza kolejka dziedziczy po list\n",
    "    def dodaj(self, el):\n",
    "        self.append(el)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:22:25.569370900Z",
     "start_time": "2023-11-27T01:22:25.531430100Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Film:('Przypadek', 10, 114)"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "k = KolejkaOglądania()\n",
    "k.dodaj(japoński)\n",
    "k.dodaj(amerykański)\n",
    "k.dodaj(polski)\n",
    "k.pop()             # GANGNAM STYLE (XD)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "I oglądamy pierwszy film z góry. Nasze rozwiązanie oferuje też wiele więcej możliwości niż zwykły stos. Możemy np. sortować nasze filmy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:22:48.255138500Z",
     "start_time": "2023-11-27T01:22:48.140830200Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[Film:('Ikiru', 9, 143), Film:('Lot nad kukułczym gniazdem', 10, 133)]"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "k.sort()\n",
    "k"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:22:52.005981Z",
     "start_time": "2023-11-27T01:22:51.969851Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[Film:('Lot nad kukułczym gniazdem', 10, 133), Film:('Ikiru', 9, 143)]"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "k.sort(key=len)\n",
    "k"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Bug czy Feature?\n",
    "Nieoczekiwanie nasza KolejkaOglądania pozwala nam sortować filmy, co może być przydatne na platformach streamingowych.\n",
    "Z drugiej strony niektórzy użytkownicy mogą uznać za dziwne, że model stosu filmów ma możliwość sortowania.\n",
    "Lepszym podejściem jest **kompozycja**. Zamiast dziedziczyć po liście, stworzyć niezależną klasę, która ma w sobie listę.\n",
    "Albo bardziej ogólnie:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:24:24.322649200Z",
     "start_time": "2023-11-27T01:24:24.267615800Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class KolejkaOglądania:\n",
    "    def __init__(self, container=None):\n",
    "        if container is None:\n",
    "            self._elementy = list()         # domyślnie trzymamy listę\n",
    "        else:\n",
    "            self._elementy = container\n",
    "\n",
    "    def dodaj(self, el):\n",
    "        self._elementy.append(el)\n",
    "\n",
    "    def obejrzyj(self):\n",
    "        return self._elementy.pop()\n",
    "\n",
    "    def __len__(self):\n",
    "        return len(self._elementy)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Nie korzystamy wprost z odziedziczonej implementacji (jw. wykonując `k.pop()`). Tylko oferujemy `obejrzyj`, w którym ukryty jest sposób dostępu i pobieranie z wewnętrznej struktury. Możemy łatwo podmienić wewnętrzną kolekcję z której korzystamy na inną, np. kolejkę."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:24:46.851356400Z",
     "start_time": "2023-11-27T01:24:46.818651600Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Film:('Przypadek', 10, 114)"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import collections\n",
    "k = KolejkaOglądania(container=collections.deque())\n",
    "k.dodaj(japoński)\n",
    "k.dodaj(polski)\n",
    "k.obejrzyj()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 1.2.3. Gęsie typowanie i abstrakcyjne klasy bazowe (klasy ABC)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Kacze typowanie może prowadzić do przypadkowych podobieństw:\n",
    "`class Artist: def draw(self):...` (rysuj), `class Gunslinger: def draw(self):...` (wyciągnij), `class Loterry: def draw(self):...` (losuj).\n",
    "Gęsie typowanie stosujmy jako uzupełnienie kaczego typowania. Obejmuje ono:\n",
    "- tworzenie podklasy z abstrakcyjnej klasy bazowej (ABC), aby było jasne, że implementujemy wcześniej zdefiniowany interfejs\n",
    "- sprawdzenie typów w czasie wykonywania programu przy użyciu klas ABC"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### Złote myśli\n",
    "Scott Mayer w \"More effective C++\" pisze \"wszystkie klasy, po których można dziedziczyć, powinny być abstrakcyjne\"\n",
    "Alex Martelli, cytowany w \"Fluent Python\", twierdzi \"możemy .. definiować swoje abstrakcyjne klasy bazowe, ale odradzam to wszystkim .. tak samo, jak odradzałbym definiowanie swoich własnych niestandardowych metaklas\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zobaczmy, jak tam nasza klasa Film. O klasach ABC można doczytać tu https://docs.python.org/3/library/collections.abc.html"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:35:10.035546Z",
     "start_time": "2025-01-13T20:35:10.029353Z"
    }
   },
   "source": [
    "from collections import abc\n",
    "isinstance(polski, abc.Sized)"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 19
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Sized rozpoznaje Film jako podklasę, dzięki implementacji `__len__`"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:35:18.363415Z",
     "start_time": "2025-01-13T20:35:18.358913Z"
    }
   },
   "source": [
    "(isinstance(polski, abc.Iterable), isinstance(polski, abc.Hashable), isinstance(polski, abc.Container), isinstance(polski, abc.Collection))"
   ],
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(True, True, False, False)"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "execution_count": 20
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Dla ostatnich dwóch brakuje nam implementacji `__contains__`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "## 2. Wielokrotne dziedziczenie"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "to możliwość wyprowadzenia klasy z więcej niż jednej klasy bazowej. C++ je obsługuje, Java i C# nie. Python tak."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Poniżej mamy przykład tzw. diamentowego dziedziczenia. Konstruując obiekt, chcemy wypisać wszystkie jego cechy. Tymczasem, startując z dołu hierarchii, dwukrotnie uruchomimy opis z klasy na szczycie hierarchii."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:35:30.732899Z",
     "start_time": "2025-01-13T20:35:30.729183Z"
    }
   },
   "source": [
    "class Kinowa:\n",
    "    def __init__(self):\n",
    "        print(\"Kinowa\")                             # do śledzenia kolejności wywołań\n",
    "\n",
    "class Komedia(Kinowa):\n",
    "    def __init__(self):\n",
    "        print(\"Komedia\")\n",
    "        Kinowa.__init__(self)\n",
    "\n",
    "class Romantyczna(Kinowa):\n",
    "    def __init__(self):\n",
    "        print(\"Romantyczna\")\n",
    "        Kinowa.__init__(self)\n",
    "\n",
    "class KomediaRomantyczna(Komedia, Romantyczna):     # przykład wielokrotnego dziedziczenia\n",
    "    def __init__(self):\n",
    "        print(\"KR\")\n",
    "        Komedia.__init__(self)\n",
    "        Romantyczna.__init__(self)\n",
    "\n",
    "kr = KomediaRomantyczna()"
   ],
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "KR\n",
      "Komedia\n",
      "Kinowa\n",
      "Romantyczna\n",
      "Kinowa\n"
     ]
    }
   ],
   "execution_count": 21
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Korzystając z `super()` udaje się nam uzyskać to, co zamierzaliśmy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:28:56.924115Z",
     "start_time": "2023-11-27T01:28:56.873477700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "KR\n",
      "Komedia\n",
      "Romantyczna\n",
      "Kinowa\n"
     ]
    }
   ],
   "source": [
    "class Kinowa:\n",
    "    def __init__(self):\n",
    "        print(\"Kinowa\")\n",
    "\n",
    "class Komedia(Kinowa):\n",
    "    def __init__(self):\n",
    "        print(\"Komedia\")\n",
    "        super().__init__()          # zamiast Kinowa.__init__()\n",
    "\n",
    "class Romantyczna(Kinowa):\n",
    "    def __init__(self):\n",
    "        print(\"Romantyczna\")\n",
    "        super().__init__()\n",
    "\n",
    "class KomediaRomantyczna(Komedia, Romantyczna):\n",
    "    def __init__(self):\n",
    "        print(\"KR\")\n",
    "        super().__init__()\n",
    "\n",
    "kr = KomediaRomantyczna()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Dodatkowo napis \"Kinowa\" wypisał się na samym końcu. Jak w takim razie ustalana jest kolejność?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "## 3. Kolejność odszukiwania metod - Method resolution order - MRO"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Znamy już z poprzednich materiałów przydatne polecenie `dir`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:29:27.888404300Z",
     "start_time": "2023-11-27T01:29:27.792611400Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['_Film__długość',\n",
       " '_Film__ocena',\n",
       " '_Film__tytuł',\n",
       " '__class__',\n",
       " '__delattr__',\n",
       " '__dict__',\n",
       " '__dir__',\n",
       " '__doc__',\n",
       " '__eq__',\n",
       " '__format__',\n",
       " '__ge__',\n",
       " '__getattribute__',\n",
       " '__getitem__',\n",
       " '__getstate__',\n",
       " '__gt__',\n",
       " '__hash__',\n",
       " '__init__',\n",
       " '__init_subclass__',\n",
       " '__iter__',\n",
       " '__le__',\n",
       " '__len__',\n",
       " '__lt__',\n",
       " '__module__',\n",
       " '__ne__',\n",
       " '__new__',\n",
       " '__reduce__',\n",
       " '__reduce_ex__',\n",
       " '__repr__',\n",
       " '__setattr__',\n",
       " '__sizeof__',\n",
       " '__str__',\n",
       " '__subclasshook__',\n",
       " '__weakref__',\n",
       " 'długość',\n",
       " 'ocena',\n",
       " 'tytuł']"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dir(polski)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Jak widzimy, nie mamy na tej liście `__mro__`. A jednak możemy go uruchomić."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:29:31.972166500Z",
     "start_time": "2023-11-27T01:29:31.930211900Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(__main__.Film, object)"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Film.__mro__                # tak"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:29:34.499527700Z",
     "start_time": "2023-11-27T01:29:34.407547400Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[__main__.KomediaRomantyczna,\n",
       " __main__.Komedia,\n",
       " __main__.Romantyczna,\n",
       " __main__.Kinowa,\n",
       " object]"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "KomediaRomantyczna.mro()    # lub tak"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:29:36.564782900Z",
     "start_time": "2023-11-27T01:29:36.521235300Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[__main__.Romantyczna, __main__.Kinowa, object]"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Romantyczna.mro()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "MRO określa kolejność wyszukiwania. Za każdym razem, gdy szukasz atrybutu w instancji lub klasie, każda klasa w MRO jest sprawdzana w podanej kolejności.\n",
    "Wyszukiwanie zatrzymuje się po pierwszym dopasowaniu.\n",
    "Zauważmy, że jak wyszło we wszystkich powyższych przykładach, wszystko dziedziczy po object."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Współdzielone dziedziczenie wielokrotne - wszystkie klasy umieszczane są na liście MRO tak, aby:\n",
    "- klasa potomna jest przed każdym z rodziców\n",
    "- jeśli klasa ma wielu rodziców, sprawdzani są oni w tej samej kolejności, co zapisani na liście dziedziczenia dziecka\n",
    "\n",
    "Kolejność określana jest zgodnie z algorytmem linearyzacji C3."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:30:06.743608200Z",
     "start_time": "2023-11-27T01:30:06.700425700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "Cannot create a consistent method resolution\norder (MRO) for bases Serial, Telenowela",
     "output_type": "error",
     "traceback": [
      "\u001B[0;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[0;31mTypeError\u001B[0m                                 Traceback (most recent call last)",
      "Cell \u001B[0;32mIn[35], line 3\u001B[0m\n\u001B[1;32m      1\u001B[0m \u001B[38;5;28;01mclass\u001B[39;00m \u001B[38;5;21;01mSerial\u001B[39;00m: \u001B[38;5;28;01mpass\u001B[39;00m\n\u001B[1;32m      2\u001B[0m \u001B[38;5;28;01mclass\u001B[39;00m \u001B[38;5;21;01mTelenowela\u001B[39;00m(Serial): \u001B[38;5;28;01mpass\u001B[39;00m\n\u001B[0;32m----> 3\u001B[0m \u001B[38;5;28;01mclass\u001B[39;00m \u001B[38;5;21;01mWenezuelska\u001B[39;00m(Serial, Telenowela): \u001B[38;5;28;01mpass\u001B[39;00m\n",
      "\u001B[0;31mTypeError\u001B[0m: Cannot create a consistent method resolution\norder (MRO) for bases Serial, Telenowela"
     ]
    }
   ],
   "source": [
    "class Serial: pass\n",
    "class Telenowela(Serial): pass\n",
    "class Wenezuelska(Serial, Telenowela): pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Dla takiej hierarchii Python zgłosił nam błąd. Tymczasem jeśli zamienimy kolejność na liście dziedziczenia klasy Wenezuelska, już będzie ok:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:30:34.025662500Z",
     "start_time": "2023-11-27T01:30:33.988554900Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Serial: pass\n",
    "class Telenowela(Serial): pass\n",
    "class Wenezuelska(Telenowela, Serial): pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Podobnie jak w wyżej omówionym przypadku konstruktorów, nie stosowanie `super()` prowadzi do nieintuicyjnego działania."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:31:01.284221600Z",
     "start_time": "2023-11-27T01:31:01.249315700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Komedia\n",
      "Romantyczna\n"
     ]
    }
   ],
   "source": [
    "class Kinowa:\n",
    "    def wypisz(self):\n",
    "        print(\"Kinowa\")\n",
    "\n",
    "class Komedia(Kinowa):\n",
    "    def wypisz(self):\n",
    "        print(\"Komedia\")\n",
    "        super().wypisz()\n",
    "\n",
    "class Romantyczna(Kinowa):\n",
    "    def wypisz(self):\n",
    "        print(\"Romantyczna\")\n",
    "\n",
    "class KomediaRomantyczna(Komedia, Romantyczna):\n",
    "    pass\n",
    "\n",
    "kr = KomediaRomantyczna()\n",
    "kr.wypisz() # co się stanie?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Nawet dobry opis. Ale dlaczego taki? Prześledźmy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:31:14.202500900Z",
     "start_time": "2023-11-27T01:31:14.136595600Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[__main__.KomediaRomantyczna,\n",
       " __main__.Komedia,\n",
       " __main__.Romantyczna,\n",
       " __main__.Kinowa,\n",
       " object]"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "KomediaRomantyczna.mro()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Przez dziedziczenie `kr` aktywuję `wypisz()` w klasie `Komedia`. Tam z kolei w implementacji `wypisz()` jest odwołanie `super()`.\n",
    "Zauważmy, że nie odnosi się ono do `wypisz()` z klasy `Kinowa`, która jest nadklasą `Komedia`.\n",
    "Odniesie się ono do następnej pozycji w liście MRO, w `Romantyczna` jest metoda `wypisz()` i to ona zostanie wywołana."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Analogicznie do konstruktorów, jeśli chcemy wykonać wszystkie funkcje z nadklas jednokrotnie, wszędzie użyjemy super."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:32:02.727640Z",
     "start_time": "2023-11-27T01:32:02.692463300Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Komedia\n",
      "Romantyczna\n",
      "Kinowa\n"
     ]
    }
   ],
   "source": [
    "class Kinowa:\n",
    "    def wypisz(self):\n",
    "        print(\"Kinowa\")\n",
    "\n",
    "class Komedia(Kinowa):\n",
    "    def wypisz(self):\n",
    "        print(\"Komedia\")\n",
    "        super().wypisz()\n",
    "\n",
    "class Romantyczna(Kinowa):\n",
    "    def wypisz(self):\n",
    "        print(\"Romantyczna\")\n",
    "        super().wypisz()\n",
    "\n",
    "class KomediaRomantyczna(Komedia, Romantyczna):\n",
    "    pass\n",
    "\n",
    "kr = KomediaRomantyczna()\n",
    "kr.wypisz() # co się stanie?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "## 4. Klasy domieszki"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 4.1. Wprowadzenie\n",
    "Klasa domieszka to klasa, która modyfikuje lub rozszerza funkcjonalność innych klas."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Wyobraźmy sobie, że mamy klasy z wielokrotnie ponownie używanym dźwiękiem do filmów (komentarze w kodzie to ciekawostki filmowe, nie programistyczne)"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:41:16.555531Z",
     "start_time": "2025-01-13T20:41:16.549353Z"
    }
   },
   "source": [
    "class KtośSpada:        # zob https://pl.wikipedia.org/wiki/Krzyk_Wilhelma\n",
    "    def dźwięk(self):   # wykorzystywany w wielu filmach, grach\n",
    "        return 'aaaah'  # potem też taki \"easter egg\" dźwiękowców filmowych\n",
    "\n",
    "class PojedynekRewolwerowy: # autor: Morricone, reż: Sergio Leone, \"The good, the bad and the ugly\"\n",
    "    def dźwięk(self):       # poniższa transkrypcja działa :) https://www.reddit.com/r/NoStupidQuestions/comments/f6jomc/whats_the_song_called_that_is_usually_used_in/\n",
    "        return 'wolololol waw waw waw ayayayayaya waw waw waw'      # Muzyka Morricone jeszcze lepsza jest w \"Pewnego razu na Dzikim Zachodzie\" Sergio Leone :)\n",
    "\n",
    "class StrasznaScena:    # autor: Bernard Herrmann, reż: Hitchcock, \"Psychoza\"\n",
    "    def dźwięk(self):\n",
    "        return 'hi hi hi hi hi'\n",
    "\n",
    "class Niepokój:         # autor: Lynch, reż: Lynch, \"Eraserhead\"\n",
    "    def dźwięk(self):   # tych dźwięków akurat chyba nikt nie użył ponownie\n",
    "        return 'aaa aaaaaaa aaaaaa'"
   ],
   "outputs": [],
   "execution_count": 22
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Oraz zupełnie niepowiązane klasy, jak np. Kosiarka."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:41:22.566514Z",
     "start_time": "2025-01-13T20:41:22.563023Z"
    }
   },
   "source": [
    "class Kosiarka:\n",
    "    def dźwięk(self):                # jedna z wielu metod, zupełnie inna natura niż w klasach opisanych wyżej\n",
    "        return 'wrrrr'\n",
    "    def koś(self, lokalizacja): pass\n",
    "    def uzupełnij_paliwo(self): pass # i wiele innych"
   ],
   "outputs": [],
   "execution_count": 23
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zauważmy, że KtośSpada i Kosiarka to klasy ze sobą zupełnie niepowiązane, nie ma między nimi relacji dziedziczenia, stosują różne metody. Cechą wspólną jest metoda `dźwięk()`. Skonstruujemy teraz klasy domieszki implementujące brakujące funkcjonalności - pogłośń i powtórz.\n",
    "Konwencja nazewnictwa zaleca dołączyć człon `Mixin` do klas domieszek (wcześniej konsekwentnie używaliśmy polskich nazw, więc przy nich zostańmy)"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:41:59.771758Z",
     "start_time": "2025-01-13T20:41:59.768946Z"
    }
   },
   "source": [
    "class PogłośńMixin:\n",
    "    def dźwięk(self):\n",
    "        return super().dźwięk().upper()\n",
    "\n",
    "class PowtórzMixin:\n",
    "    def dźwięk(self):\n",
    "        return 2*(super().dźwięk() + \" \")"
   ],
   "outputs": [],
   "execution_count": 24
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Klasa taka sama w sobie nie działa (deleguje do nieistniejącej klasy nadrzędnej)."
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:42:01.571359Z",
     "start_time": "2025-01-13T20:42:01.521047Z"
    }
   },
   "source": [
    "powtarzarka = PowtórzMixin()\n",
    "powtarzarka.dźwięk()"
   ],
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "'super' object has no attribute 'dźwięk'",
     "output_type": "error",
     "traceback": [
      "\u001B[0;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[0;31mAttributeError\u001B[0m                            Traceback (most recent call last)",
      "Cell \u001B[0;32mIn[25], line 2\u001B[0m\n\u001B[1;32m      1\u001B[0m powtarzarka \u001B[38;5;241m=\u001B[39m PowtórzMixin()\n\u001B[0;32m----> 2\u001B[0m powtarzarka\u001B[38;5;241m.\u001B[39mdźwięk()\n",
      "Cell \u001B[0;32mIn[24], line 7\u001B[0m, in \u001B[0;36mPowtórzMixin.dźwięk\u001B[0;34m(self)\u001B[0m\n\u001B[1;32m      6\u001B[0m \u001B[38;5;28;01mdef\u001B[39;00m \u001B[38;5;21mdźwięk\u001B[39m(\u001B[38;5;28mself\u001B[39m):\n\u001B[0;32m----> 7\u001B[0m     \u001B[38;5;28;01mreturn\u001B[39;00m \u001B[38;5;241m2\u001B[39m\u001B[38;5;241m*\u001B[39m(\u001B[38;5;28msuper\u001B[39m()\u001B[38;5;241m.\u001B[39mdźwięk() \u001B[38;5;241m+\u001B[39m \u001B[38;5;124m\"\u001B[39m\u001B[38;5;124m \u001B[39m\u001B[38;5;124m\"\u001B[39m)\n",
      "\u001B[0;31mAttributeError\u001B[0m: 'super' object has no attribute 'dźwięk'"
     ]
    }
   ],
   "execution_count": 25
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Możemy za to za ich pomocą implementować nową funkcjonalność"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    },
    "ExecuteTime": {
     "end_time": "2025-01-13T20:42:04.184062Z",
     "start_time": "2025-01-13T20:42:04.181217Z"
    }
   },
   "source": [
    "class GłośneSpadanie(PogłośńMixin, KtośSpada): pass\n",
    "class StaraKosiarka(PowtórzMixin, Kosiarka): pass\n",
    "class DługiGłośnyPojedynek(PowtórzMixin, PogłośńMixin, PojedynekRewolwerowy): pass"
   ],
   "outputs": [],
   "execution_count": 26
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "I mamy:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:36:22.889644100Z",
     "start_time": "2023-11-27T01:36:22.851946100Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'AAAAH'"
      ]
     },
     "execution_count": 45,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "upadek = GłośneSpadanie()\n",
    "upadek.dźwięk()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:36:24.895012800Z",
     "start_time": "2023-11-27T01:36:24.831575400Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'wrrrr wrrrr '"
      ]
     },
     "execution_count": 46,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nie_chce_zapalić = StaraKosiarka()\n",
    "nie_chce_zapalić.dźwięk()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:36:29.976064400Z",
     "start_time": "2023-11-27T01:36:29.942235100Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'WOLOLOLOL WAW WAW WAW AYAYAYAYAYA WAW WAW WAW WOLOLOLOL WAW WAW WAW AYAYAYAYAYA WAW WAW WAW '"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "klimatyczna_scena = DługiGłośnyPojedynek()\n",
    "klimatyczna_scena.dźwięk()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Spójrzmy teraz na MRO naszej klasy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:36:47.823090800Z",
     "start_time": "2023-11-27T01:36:47.791140200Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[__main__.DługiGłośnyPojedynek,\n",
       " __main__.PowtórzMixin,\n",
       " __main__.PogłośńMixin,\n",
       " __main__.PojedynekRewolwerowy,\n",
       " object]"
      ]
     },
     "execution_count": 48,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "DługiGłośnyPojedynek.mro()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 4.2. Przykłady zastosowań"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Spróbujmy przeedytować dźwięk na pierwszym filmie dźwiękowym."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:37:22.090935300Z",
     "start_time": "2023-11-27T01:37:22.011717300Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "'super' object has no attribute 'dźwięk'",
     "output_type": "error",
     "traceback": [
      "\u001B[0;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[0;31mAttributeError\u001B[0m                            Traceback (most recent call last)",
      "Cell \u001B[0;32mIn[49], line 3\u001B[0m\n\u001B[1;32m      1\u001B[0m \u001B[38;5;28;01mclass\u001B[39;00m \u001B[38;5;21;01mDługiGłośnyFilm\u001B[39;00m(PowtórzMixin, PogłośńMixin, Film): \u001B[38;5;28;01mpass\u001B[39;00m\n\u001B[1;32m      2\u001B[0m dźwiękowy \u001B[38;5;241m=\u001B[39m DługiGłośnyFilm(\u001B[38;5;124m\"\u001B[39m\u001B[38;5;124mThe jazz singer\u001B[39m\u001B[38;5;124m\"\u001B[39m, \u001B[38;5;241m7\u001B[39m, \u001B[38;5;241m88\u001B[39m)\n\u001B[0;32m----> 3\u001B[0m \u001B[43mdźwiękowy\u001B[49m\u001B[38;5;241;43m.\u001B[39;49m\u001B[43mdźwięk\u001B[49m\u001B[43m(\u001B[49m\u001B[43m)\u001B[49m\n",
      "Cell \u001B[0;32mIn[42], line 7\u001B[0m, in \u001B[0;36mPowtórzMixin.dźwięk\u001B[0;34m(self)\u001B[0m\n\u001B[1;32m      6\u001B[0m \u001B[38;5;28;01mdef\u001B[39;00m \u001B[38;5;21mdźwięk\u001B[39m(\u001B[38;5;28mself\u001B[39m):\n\u001B[0;32m----> 7\u001B[0m     \u001B[38;5;28;01mreturn\u001B[39;00m \u001B[38;5;241m2\u001B[39m\u001B[38;5;241m*\u001B[39m(\u001B[38;5;28;43msuper\u001B[39;49m\u001B[43m(\u001B[49m\u001B[43m)\u001B[49m\u001B[38;5;241;43m.\u001B[39;49m\u001B[43mdźwięk\u001B[49m\u001B[43m(\u001B[49m\u001B[43m)\u001B[49m \u001B[38;5;241m+\u001B[39m \u001B[38;5;124m\"\u001B[39m\u001B[38;5;124m \u001B[39m\u001B[38;5;124m\"\u001B[39m)\n",
      "Cell \u001B[0;32mIn[42], line 3\u001B[0m, in \u001B[0;36mPogłośńMixin.dźwięk\u001B[0;34m(self)\u001B[0m\n\u001B[1;32m      2\u001B[0m \u001B[38;5;28;01mdef\u001B[39;00m \u001B[38;5;21mdźwięk\u001B[39m(\u001B[38;5;28mself\u001B[39m):\n\u001B[0;32m----> 3\u001B[0m     \u001B[38;5;28;01mreturn\u001B[39;00m \u001B[38;5;28;43msuper\u001B[39;49m\u001B[43m(\u001B[49m\u001B[43m)\u001B[49m\u001B[38;5;241;43m.\u001B[39;49m\u001B[43mdźwięk\u001B[49m()\u001B[38;5;241m.\u001B[39mupper()\n",
      "\u001B[0;31mAttributeError\u001B[0m: 'super' object has no attribute 'dźwięk'"
     ]
    }
   ],
   "source": [
    "class DługiGłośnyFilm(PowtórzMixin, PogłośńMixin, Film): pass\n",
    "dźwiękowy = DługiGłośnyFilm(\"The jazz singer\", 7, 88)\n",
    "dźwiękowy.dźwięk()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Rzeczywiście, klasa film nie ma przecież metody `dźwięk`. Możemy rozwiązać ten problem za pomocą wspólnego rodzica naszych domieszek. Jeśli nie będzie dźwięku, zwrócimy pusty napis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:37:33.229858400Z",
     "start_time": "2023-11-27T01:37:33.208884700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class DźwiękMixin:\n",
    "    def dźwięk(self):\n",
    "        try:\n",
    "            ret = super().dźwięk()\n",
    "        except AttributeError:          # gdy nie znajdziemy metody dźwięk()\n",
    "            ret = ''\n",
    "        return ret\n",
    "\n",
    "# POZOSTAŁE METODY ZOSTAJĄ BEZ ZMIAN\n",
    "class PogłośńMixin(DźwiękMixin):\n",
    "    def dźwięk(self):\n",
    "        return super().dźwięk().upper()\n",
    "\n",
    "class PowtórzMixin(DźwiękMixin):\n",
    "    def dźwięk(self):\n",
    "        return 2*(super().dźwięk() + \" \")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:38:29.303582900Z",
     "start_time": "2023-11-27T01:38:29.276673100Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class DługiGłośnyFilm(PowtórzMixin, PogłośńMixin, Film): pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:38:36.650160900Z",
     "start_time": "2023-11-27T01:38:36.605660200Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'  '"
      ]
     },
     "execution_count": 52,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dźwiękowy = DługiGłośnyFilm(\"The jazz singer\", 7, 88)\n",
    "dźwiękowy.dźwięk()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Udało nam się. Nie tylko nie wystąpił błąd, ale jak nie ma zdefiniowanego dźwięku, mamy transkrypcję ciszy.\n",
    "\n",
    "Przyjrzyjmy się jeszcze kolejności wywołań i przywołajmy poprzednią klasę `DługiGłośnyPojedynek`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:39:11.477565700Z",
     "start_time": "2023-11-27T01:39:11.453598700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[<class '__main__.DługiGłośnyFilm'>, <class '__main__.PowtórzMixin'>, <class '__main__.PogłośńMixin'>, <class '__main__.DźwiękMixin'>, <class '__main__.Film'>, <class 'object'>]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[__main__.DługiGłośnyPojedynek,\n",
       " __main__.PowtórzMixin,\n",
       " __main__.PogłośńMixin,\n",
       " __main__.DźwiękMixin,\n",
       " __main__.PojedynekRewolwerowy,\n",
       " object]"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "class DługiGłośnyPojedynek(PowtórzMixin, PogłośńMixin, PojedynekRewolwerowy): pass\n",
    "print(DługiGłośnyFilm.mro())\n",
    "DługiGłośnyPojedynek.mro()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zauważmy, że klasa pod `obiect` czyli `Film` / `PojedynekRewolwerowy` są w MRO po `DźwiękMixin`.\n",
    "Zatem, gdyby w `DźwiękMixin` zwracać po prostu pusty napis, `dźwięk` z `PojedynekRewolwerowy` zostałby przez niego zastąpiony.\n",
    "Dlatego w naszej implementacji użyliśmy `super().dźwięk()` i działa:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:40:27.798061100Z",
     "start_time": "2023-11-27T01:40:27.767581900Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'WOLOLOLOL WAW WAW WAW AYAYAYAYAYA WAW WAW WAW WOLOLOLOL WAW WAW WAW AYAYAYAYAYA WAW WAW WAW '"
      ]
     },
     "execution_count": 54,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "klimatyczna_scena = DługiGłośnyPojedynek()\n",
    "klimatyczna_scena.dźwięk()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "### Do zapamiętania:\n",
    "- W Javie dopuszczalne jest wielokrotne dziedziczenie interfejsów, w podobnym duchu korzystaj z wielodziedziczenia w Pythonie\n",
    "- klasy ABC mogą mieć rolę interfejsu, mogą też mieć rolę klas domieszkowych"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Przykłady klas domieszkowych:\n",
    "- dla zarządzania wątkami w socketserver - ThreadingMixIn i ForkingMixIn\n",
    "- dla widoków w Django (framework do aplikacji internetowych) - TemplateResponseMixin, ContextMixin, ...\n",
    "- dla drzew - np. w module filogenetycznym w biopythonie - Bio.Phylo.BaseTree.TreeMixin\n",
    "..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "## 5. Różne"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 5.0. A teraz coś z zupełnie innej beczki ..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "##### 5.0.1. Metoda `__new__`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:40:51.067193500Z",
     "start_time": "2023-11-27T01:40:51.037269900Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "new\n",
      "init\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<__main__.Statysta at 0x7fc84d8ab5f0>"
      ]
     },
     "execution_count": 55,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "class Statysta:\n",
    "    def __new__(cls):\n",
    "        print(\"new\")\n",
    "        return super().__new__(cls)\n",
    "\n",
    "    def __init__(self):\n",
    "        print(\"init\")\n",
    "\n",
    "Statysta()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Wywołanie `Statysta()` wywołuje metodę `__new__` z klasy Statysta, ta z kolei (jak widać) wywołuje `__new__` z nadklasy, z nazwą klasy jako parametrem, co (dokładniej: w klasie object) powoduje stworzenie \"pustej\" instancji.\n",
    "\n",
    "Ta z kolei następnie jest przekazywana do `__init__` z klasy Statysta.\n",
    "\n",
    "Metoda `__new__` to metoda statyczna, jej pierwszy argument `cls` to referencja do klasy, z której jest wywoływana (zwykle jest to klasa potomna klasy, w której `__new__` jest zdefiniowana).\n",
    "\n",
    "Nadpisanie `__new__` może: (1) posłużyć temu, by zapobiec tworzeniu instancji w określonych okolicznościach, (2) być wykorzystane do stworzenia instancji trochę innej klasy, albo (3) w ogóle do zwrócenia istniejącego obiektu (chociaż w tym przypadku wywołane zostanie na nim `__init__` - nie róbmy tego)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "##### 5.0.2. `@classmethod` i `@staticmethod`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Dekorator `@classmethod` zmienia sposób wywołania metody, aby jako pierwszy argument otrzymywała samą klasę (oznaczaną zwykle jako `cls`) zamiast instancji (oznaczaną `self`).\n",
    "\n",
    "Najczęstsze zastosowanie tej metody to alternatywne konstruktory (`@classmethod` pozwala rozwiązać problemy, które w innych językach można rozwiązać korzystając z polimorfizmu konstruktora). W Pythonie polimorfizm obsługują nie tylko obiekty, ale też klasy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:42:17.931826900Z",
     "start_time": "2023-11-27T01:42:17.895027100Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class LicznikInstancjiMixin:\n",
    "    __licznik = 0\n",
    "    def __init__(self):\n",
    "        self.zwieksz_licznik(1)\n",
    "\n",
    "    @classmethod\n",
    "    def zwieksz_licznik(cls, ile):\n",
    "        cls.__licznik += ile\n",
    "\n",
    "    @classmethod\n",
    "    def licznik(cls):\n",
    "        return cls.__licznik"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:42:39.496422700Z",
     "start_time": "2023-11-27T01:42:39.450485600Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class KillBill(LicznikInstancjiMixin): pass\n",
    "\n",
    "class OjciecChrzestny(LicznikInstancjiMixin): pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:42:42.533582600Z",
     "start_time": "2023-11-27T01:42:42.491788200Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 1\n",
      "2 2\n",
      "Ojciec Chrzestny 3 z 3\n",
      "Kill Bill 2 z 2\n"
     ]
    }
   ],
   "source": [
    "p1 = KillBill()\n",
    "print(p1.licznik(), KillBill.licznik())\n",
    "p2 = KillBill()\n",
    "print(p2.licznik(), KillBill.licznik())\n",
    "\n",
    "d1, d2, d3 = OjciecChrzestny(), OjciecChrzestny(), OjciecChrzestny()\n",
    "print(\"Ojciec Chrzestny\", d1.licznik(), \"z\", OjciecChrzestny.licznik())\n",
    "print(\"Kill Bill\", p2.licznik(), \"z\", KillBill.licznik())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Jak widać, liczniki instancji są niezależne w każdej z klas."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Dekorator `@staticmethod` zmienia metodę, aby nie otrzymywała żadnego specjalnego pierwszego argumentu. Taka metoda nie ma dostępu do atrybutów klasowych i atrybutów instancji - nie może ona mieć parametrów `cls` (charakterystycznych dla metod klasowych) i `self` (związanych z instancja klasy).\n",
    "\n",
    "Przeanalizujmy powyższe rozwiązanie, gdyby zamiast `@classmethod` implementować `@staticmethod`. Metody `zwieksz_licznik` i `licznik` nie mogą mieć parametru `cls`, zatem w najlepszym razie mogą używać tylko pełnej nazwy (jednej) klasy i siłą rzeczy taki licznik byłby wspólny:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:43:41.787674500Z",
     "start_time": "2023-11-27T01:43:41.730094100Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class WspólnyLicznikInstancji:\n",
    "    __licznik = 0\n",
    "    def __init__(self):\n",
    "        self.zwieksz_licznik(1)\n",
    "\n",
    "    @staticmethod\n",
    "    def zwieksz_licznik(ile):\n",
    "        WspólnyLicznikInstancji.__licznik += ile\n",
    "\n",
    "    @staticmethod\n",
    "    def licznik():\n",
    "        return WspólnyLicznikInstancji.__licznik"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:43:43.631481300Z",
     "start_time": "2023-11-27T01:43:43.584175900Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 1\n",
      "2 2\n",
      "Ojciec Chrzestny 5 z 5\n",
      "Kill Bill 5 z 5\n"
     ]
    }
   ],
   "source": [
    "# TA CZĘŚĆ POZOSTAJE BEZ ZMIAN\n",
    "class KillBill(WspólnyLicznikInstancji): pass\n",
    "\n",
    "class OjciecChrzestny(WspólnyLicznikInstancji): pass\n",
    "\n",
    "p1 = KillBill()\n",
    "print(p1.licznik(), KillBill.licznik())\n",
    "p2 = KillBill()\n",
    "print(p2.licznik(), KillBill.licznik())\n",
    "\n",
    "d1, d2, d3 = OjciecChrzestny(), OjciecChrzestny(), OjciecChrzestny()\n",
    "print(\"Ojciec Chrzestny\", d1.licznik(), \"z\", OjciecChrzestny.licznik())\n",
    "print(\"Kill Bill\", p2.licznik(), \"z\", KillBill.licznik())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "I mamy \"Ojca Chrzestnego 5\" ..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 5.1. Dyspozycja (ang. dispatch) na podstawie typu\n",
    "Zamiast nieeleganckiej serii if-else i sprawdzania isinstance(), możemy stworzyć klasę, która oferuje różne metody dla różnych obiektów. Zobacz poniżej:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:44:18.038021100Z",
     "start_time": "2023-11-27T01:44:17.983223Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "spadam\n",
      "koszę\n",
      "Oglądam ('Ikiru', 9, 143)\n"
     ]
    }
   ],
   "source": [
    "class Dispatcher:\n",
    "    def obsłuż(self, obj):\n",
    "        for ty in type(obj).__mro__:    # wyszukuję po liście MRO odpowiedniej funkcji\n",
    "            met = getattr(self, f'obsłuż_{ty.__name__}', None)\n",
    "            if met:\n",
    "                return met(obj)\n",
    "        raise RuntimeError(f'Brak obsługi dla {obj}')\n",
    "\n",
    "    def obsłuż_Kosiarka(self, obj):\n",
    "        print(\"koszę\")\n",
    "    def obsłuż_KtośSpada(self, obj):\n",
    "        print(\"spadam\")\n",
    "    def obsłuż_Film(self, obj):\n",
    "        print(f\"Oglądam {obj}\")\n",
    "\n",
    "dispatcher = Dispatcher()\n",
    "dispatcher.obsłuż(KtośSpada())\n",
    "dispatcher.obsłuż(StaraKosiarka())\n",
    "dispatcher.obsłuż(japoński)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zauważ, że wykorzystaliśmy MRO i dla `StaraKosiarka()` wywołała się metoda `obsłuż_Kosiarka`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 5.2 Dekorator klasy\n",
    "to funkcja, która pobiera klasę jako dane wejściowe i zwraca klasę jako dane wyjściowe."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "##### 5.2.1. Dekorator klasy, jako alternatywa dla klasy domieszkowej\n",
    "Dekorator klasy ma wiele zastosowań, tutaj przedstawimy alternatywne rozwiązanie dla klasy domieszkowej.\n",
    "Funkcje `głośno` i `powtórz` zastąpią `PogłośńMixin` i `PowtórzMixin`, jako dekorator klasy `Kosiarka`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:46:04.407751Z",
     "start_time": "2023-11-27T01:46:04.338317800Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "def głośno(klasa):\n",
    "    oryg_dźwięk = klasa.dźwięk\n",
    "    def dźwięk(self):\n",
    "        return oryg_dźwięk(self).upper()\n",
    "    klasa.dźwięk = dźwięk\n",
    "    return klasa\n",
    "\n",
    "def powtórz(klasa):\n",
    "    oryg_dźwięk = klasa.dźwięk\n",
    "    def dźwięk(self):\n",
    "        return 2*(oryg_dźwięk(self) + \" \")\n",
    "    klasa.dźwięk = dźwięk\n",
    "    return klasa\n",
    "\n",
    "@powtórz\n",
    "@głośno\n",
    "class Kosiarka:\n",
    "    def dźwięk(self):\n",
    "        return 'wrrr'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:46:31.708153Z",
     "start_time": "2023-11-27T01:46:31.650096400Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'WRRR WRRR '"
      ]
     },
     "execution_count": 63,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "k = Kosiarka()\n",
    "k.dźwięk()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "##### 5.2.2 A teraz użyjemy dekoratora klasy do rejestracji klas.\n",
    "Przykładem zastosowania mogą być implementacje obsługi dekoderów, gdzie chcemy wybrać odpowiedni do obsługi naszego typu plików.\n",
    "\n",
    "Oczywiście, my przenieśmy się do świata filmów. \n",
    "Mamy szereg klas reżyserów. Każdy ma `cechy_filmów`, które definiują, jak wpływa na Widza w metodzie `wpłyń`.\n",
    "Załóżmy, że chcemy wybrać klasę reżysera, podając cechę filmu, aby dostać oczekiwany wpływ na widza."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:47:30.818010300Z",
     "start_time": "2023-11-27T01:47:30.740707300Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "_rejestr = {}                                   # słownik    klucz: cecha    wartość: klasa reżysera\n",
    "def rejestr_reżyserów(klasa):                   # klasa reżyserów\n",
    "    for cecha in klasa.cechy_filmów:\n",
    "        _rejestr[cecha] = klasa                 # w rejestrze zapisuję\n",
    "    return klasa\n",
    "\n",
    "def wybierz_reżysera(cecha):\n",
    "    return _rejestr[cecha]()                    # tworzy obiekt klasy pobranej z rejestru"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Przed każdą klasą musimy napisać dekorator (niebawem zobaczymy, jak to zrobić w jednej klasie)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:48:33.655842100Z",
     "start_time": "2023-11-27T01:48:33.593928Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "@rejestr_reżyserów\n",
    "class Capra:\n",
    "    cechy_filmów = ['optymizm', 'chce się żyć']\n",
    "    def wpłyń(self, widz): pass                     # pokrzepia na duchu\n",
    "\n",
    "@rejestr_reżyserów\n",
    "class Hitchcock:\n",
    "    cechy_filmów = ['emocjonujący', 'potrafi przestraszyć']\n",
    "    def wpłyń(self, widz): pass                     # powoduje katharsis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:48:36.412676800Z",
     "start_time": "2023-11-27T01:48:36.351836700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "reżyser = wybierz_reżysera('optymizm')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:48:37.715208400Z",
     "start_time": "2023-11-27T01:48:37.670362200Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<__main__.Capra at 0x7fc84d8a9ee0>"
      ]
     },
     "execution_count": 68,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reżyser"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "I już wiemy, że wywołanie `reżyser.wpłyń(obj)` zadziała według oczekiwanej cechy \"optymizm\"."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 5.3. Nadzorowane dziedziczenie\n",
    "Klasa nadrzędna może wykonywać akcje w imieniu swoich podklas dzięki `__init_subclass__`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zamast funkcji `rejestr_reżyserów` użytej jako dekoratora klas (Capra, Hitchcock). Tworzymy klasę `Reżyser` po której będą dziedziczyć reżyserzy (Capra, Hitchcock, ...) i zastosujemy `__init_subclass__()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:49:12.891886700Z",
     "start_time": "2023-11-27T01:49:12.866729700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Reżyser:\n",
    "    _rejestr = {}\n",
    "    @classmethod\n",
    "    def __init_subclass__(klasa):\n",
    "        for cecha in klasa.cechy_filmów:\n",
    "            Reżyser._rejestr[cecha] = klasa"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Funkcja `wybierz_reżysera` podobnie tworzy klasę z rejestru."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:50:07.805149700Z",
     "start_time": "2023-11-27T01:50:07.760270200Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "def wybierz_reżysera(cecha):\n",
    "    return Reżyser._rejestr[cecha]()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Klasy zamiast dekoratora przed klasą, dziedziczą po `Reżyser`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:50:39.616378400Z",
     "start_time": "2023-11-27T01:50:39.582802600Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Capra(Reżyser):\n",
    "    cechy_filmów = ['optymizm', 'chce się zyć']\n",
    "    def wpłyń(self, widz): pass                     # pokrzepia na duchu\n",
    "\n",
    "class Hitchcock(Reżyser):\n",
    "    cechy_filmów = ['emocjonujący', 'potrafi przestraszyć']\n",
    "    def oglądaj(self, widz): pass                   # powoduje katharsis"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Wynik będzie taki sam."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:50:45.954575500Z",
     "start_time": "2023-11-27T01:50:45.892576400Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<__main__.Capra at 0x7fc84d8abda0>"
      ]
     },
     "execution_count": 72,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reżyser = wybierz_reżysera('optymizm')\n",
    "reżyser"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 5.4. Zmniejszenie wykorzystania pamięci za pomocą `__slots__`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Standardowo, stan powiązany z instancją każdej klasy przechowywany jest w słowniku, który jest dostępny jako atrybut instancji (`__dict__`). Jeśli tworzymy bardzo dużą liczbę instancji, to mamy bardzo dużą liczbę słowników, a więc obciąża to pamięć. Gdy zestaw nazw atrybutów jest stały (a zwykle tak jest), można te nazwy zapisać w specjalnej zmiennej klasy o nazwie `__slots__`. Dzięki temu dostęp do nich staje się szybszy, bo nie przechodzi przez `__dict__`. A dokładniej, atrybut `__dict__` w ogóle nie jest tworzony dla instancji takiej klasy, co powoduje też, że instancja zużywa mniej pamięci."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:51:54.666112Z",
     "start_time": "2023-11-27T01:51:54.620193500Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Montaż:\n",
    "    __slots__ = ('autor', 'metoda')\n",
    "    def __init__(self, autor, sposób):\n",
    "        self.autor = autor\n",
    "        self.metoda = sposób"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Uwagi:\n",
    "- jeśli klasa dziedziczy po klasie gdzie jest `__slots__`, to również musi zdefiniować `__slots__`, ponieważ dziedziczony atrybut jest ignorowany przez interpreter. Gdy o tym zapomnimy, nasze rozwiązanie będzie działać wolniej i zużyje więcej pamięci niż w przypadku bez `__slots__` w żadnej z klas.\n",
    "- w dziedziczeniu wielokrotnym, jeśli wiele klas bazowych ma niepuste `__slots__`, otrzymamy `TypeError`\n",
    "- pamiętaj, że nie ma już `__dict__`, z którego zewnętrzne biblioteki i narzędzia do obsługi obiektów mogą korzystać\n",
    "- użycie slots jest dość szczególne, ma znaczenie gdy obsługujemy miliony instancji, w większości przypadków użycie pandas może być najlepszą opcją\n",
    "- oprócz wymienionej na początku literatury - zainteresowanych odsyłam do [https://stackoverflow.com/questions/472000/usage-of-slots](https://stackoverflow.com/questions/472000/usage-of-slots)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "## 6. Metaklasy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Kiedy definiujesz klasę w Pythonie, sama definicja staje się obiektem.\n",
    "Tworzenie obiektu klasy kontrolowane jest przez specjalny rodzaj klasy zwany metaklasą."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:53:03.566514800Z",
     "start_time": "2023-11-27T01:53:03.509292300Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Scenariusz: pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Dopiero zaczynamy. Nie mamy jeszcze, żadnego obiektu danej klasy, ale możemy zrobić to:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:53:18.781075900Z",
     "start_time": "2023-11-27T01:53:18.724149500Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 75,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "isinstance(Scenariusz, object)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Skoro Scenariusz istnieje, coś musiało go stworzyć. Zobaczmy:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:53:24.478008400Z",
     "start_time": "2023-11-27T01:53:24.437840800Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "type"
      ]
     },
     "execution_count": 76,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Scenariusz.__class__"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Kiedy klasa definiowana jest przez `class` dzieją się następujące rzeczy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:53:46.617304200Z",
     "start_time": "2023-11-27T01:53:46.584260700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "namespace = type.__prepare__('Scenariusz', ())      # utwórz przestrzeń nazw klas\n",
    "exec('''pass''', globals(), namespace)              # wykonaj treść klasy\n",
    "Scenariusz = type('Scenariusz', (), namespace)      # utwórz ostateczny obiekt klasy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 6.1. Przykład 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Wiemy już, że przeciążanie nie działa w Pythonie. Zduplikowane definicje działają tak, że druga zastępuje pierwszą. Chcemy wyłapać takie przypadki w naszym kodzie. Zastosujemy metaklasę."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:54:48.645653Z",
     "start_time": "2023-11-27T01:54:48.596776700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Słownik(dict):                            # Słownik dla przestrzeni nazw klasy; dziedziczy po dict\n",
    "    def __setitem__(self, key, value):          # dodanie do naszego Słownika\n",
    "        if key in self:                         # sprawdza, czy był element, jak tak to błąd\n",
    "            raise AttributeError(f'{key} już zdefiniowany')\n",
    "        super().__setitem__(key, value)         # jak nie to wywołuje standardową metodę słownika"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Tworzymy teraz naszą metaklasę `BezDuplikacjiMeta`. Dziedziczy ona po `type`. Tworzymy własną `__prepare__`, aby wykorzystać nasz `Słownik`, który będzie zgłaszał błąd, jeśli nazwa definicji się powtórzy przy implementacji klasy z naszą metaklasą."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:55:19.655732400Z",
     "start_time": "2023-11-27T01:55:19.619756Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class BezDuplikacjiMeta(type):\n",
    "    @classmethod\n",
    "    def __prepare__(metacls, name, bases):\n",
    "        return Słownik()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Teraz możemy zdefiniować jakąś klasę i wskazać jej metaklasę."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:55:25.076305700Z",
     "start_time": "2023-11-27T01:55:24.983865900Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Człowiek(metaclass=BezDuplikacjiMeta):\n",
    "    pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Metaklasę się dziedziczy. Klasy, gdzie nie wskazuje się dziedziczenia, dziedziczą po `object` metaklasę `type`.\n",
    "Stworzymy teraz klasę `Aktor`, która dziedziczy po `Człowiek` i w ten sposób dotyczy jej metaklasa `BezDuplikacjiMeta`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:55:34.240208500Z",
     "start_time": "2023-11-27T01:55:34.150447400Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "graj już zdefiniowany",
     "output_type": "error",
     "traceback": [
      "\u001B[0;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[0;31mAttributeError\u001B[0m                            Traceback (most recent call last)",
      "Cell \u001B[0;32mIn[81], line 1\u001B[0m\n\u001B[0;32m----> 1\u001B[0m \u001B[38;5;28;43;01mclass\u001B[39;49;00m\u001B[43m \u001B[49m\u001B[38;5;21;43;01mAktor\u001B[39;49;00m\u001B[43m(\u001B[49m\u001B[43mCzłowiek\u001B[49m\u001B[43m)\u001B[49m\u001B[43m:\u001B[49m\n\u001B[1;32m      2\u001B[0m \u001B[43m    \u001B[49m\u001B[38;5;28;43;01mdef\u001B[39;49;00m\u001B[43m \u001B[49m\u001B[38;5;21;43mgraj\u001B[39;49m\u001B[43m(\u001B[49m\u001B[38;5;28;43mself\u001B[39;49m\u001B[43m)\u001B[49m\u001B[43m:\u001B[49m\u001B[43m \u001B[49m\u001B[38;5;28;43;01mpass\u001B[39;49;00m\n\u001B[1;32m      3\u001B[0m \u001B[43m    \u001B[49m\u001B[38;5;28;43;01mdef\u001B[39;49;00m\u001B[43m \u001B[49m\u001B[38;5;21;43mgraj\u001B[39;49m\u001B[43m(\u001B[49m\u001B[38;5;28;43mself\u001B[39;49m\u001B[43m,\u001B[49m\u001B[43m \u001B[49m\u001B[43mfilm\u001B[49m\u001B[43m)\u001B[49m\u001B[43m:\u001B[49m\u001B[43m \u001B[49m\u001B[38;5;28;43;01mpass\u001B[39;49;00m\n",
      "Cell \u001B[0;32mIn[81], line 3\u001B[0m, in \u001B[0;36mAktor\u001B[0;34m()\u001B[0m\n\u001B[1;32m      1\u001B[0m \u001B[38;5;28;01mclass\u001B[39;00m \u001B[38;5;21;01mAktor\u001B[39;00m(Człowiek):\n\u001B[1;32m      2\u001B[0m     \u001B[38;5;28;01mdef\u001B[39;00m \u001B[38;5;21mgraj\u001B[39m(\u001B[38;5;28mself\u001B[39m): \u001B[38;5;28;01mpass\u001B[39;00m\n\u001B[0;32m----> 3\u001B[0m     \u001B[38;5;28;43;01mdef\u001B[39;49;00m\u001B[43m \u001B[49m\u001B[38;5;21;43mgraj\u001B[39;49m\u001B[43m(\u001B[49m\u001B[38;5;28;43mself\u001B[39;49m\u001B[43m,\u001B[49m\u001B[43m \u001B[49m\u001B[43mfilm\u001B[49m\u001B[43m)\u001B[49m\u001B[43m:\u001B[49m\u001B[43m \u001B[49m\u001B[38;5;28;43;01mpass\u001B[39;49;00m\n",
      "Cell \u001B[0;32mIn[78], line 4\u001B[0m, in \u001B[0;36mSłownik.__setitem__\u001B[0;34m(self, key, value)\u001B[0m\n\u001B[1;32m      2\u001B[0m \u001B[38;5;28;01mdef\u001B[39;00m \u001B[38;5;21m__setitem__\u001B[39m(\u001B[38;5;28mself\u001B[39m, key, value):          \u001B[38;5;66;03m# dodanie do naszego Słownika\u001B[39;00m\n\u001B[1;32m      3\u001B[0m     \u001B[38;5;28;01mif\u001B[39;00m key \u001B[38;5;129;01min\u001B[39;00m \u001B[38;5;28mself\u001B[39m:                         \u001B[38;5;66;03m# sprawdza, czy był element, jak tak to błąd\u001B[39;00m\n\u001B[0;32m----> 4\u001B[0m         \u001B[38;5;28;01mraise\u001B[39;00m \u001B[38;5;167;01mAttributeError\u001B[39;00m(\u001B[38;5;124mf\u001B[39m\u001B[38;5;124m'\u001B[39m\u001B[38;5;132;01m{\u001B[39;00mkey\u001B[38;5;132;01m}\u001B[39;00m\u001B[38;5;124m już zdefiniowany\u001B[39m\u001B[38;5;124m'\u001B[39m)\n\u001B[1;32m      5\u001B[0m     \u001B[38;5;28msuper\u001B[39m()\u001B[38;5;241m.\u001B[39m\u001B[38;5;21m__setitem__\u001B[39m(key, value)\n",
      "\u001B[0;31mAttributeError\u001B[0m: graj już zdefiniowany"
     ]
    }
   ],
   "source": [
    "class Aktor(Człowiek):\n",
    "    def graj(self): pass\n",
    "    def graj(self, film): pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Hurra, mamy nasz błąd."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "#### 6.2. Przykład 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Wykorzystamy teraz metaklasę do przepisania zawartości przestrzeni nazw klasy przed utworzeniem obiektu klasy.\n",
    "Pewne cechy klasy są ustalane w momencie definiowania klasy i nie mogą być później modyfikowane. Przykładem jest omówione wyżej `__slots__`.\n",
    "Poniżej mamy metaklasę, która na podstawie sygnatury metody `__init__`, automatycznie ustawia atrybut `__slots__`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:56:09.847578200Z",
     "start_time": "2023-11-27T01:56:09.785292700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "import inspect\n",
    "\n",
    "class SlotMeta(type):\n",
    "    @staticmethod\n",
    "    def __new__(metaklasa, nazwa_nowej_klasy, klasy_bazowe, atrybuty):\n",
    "        if '__init__' in atrybuty:                                      # jeśli jest init tworzę slots\n",
    "            sygnatura = inspect.signature(atrybuty['__init__'])\n",
    "            __slots__ = tuple(sygnatura.parameters)[1:]\n",
    "        else:\n",
    "            __slots__ = ()                                              # jeśli nie to slots pusty\n",
    "        atrybuty['__slots__'] = __slots__\n",
    "        return super().__new__(metaklasa, nazwa_nowej_klasy, klasy_bazowe, atrybuty)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:56:11.371850300Z",
     "start_time": "2023-11-27T01:56:11.330260300Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Człowiek(metaclass=SlotMeta):\n",
    "    pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Teraz wszyscy dziedziczący po `Człowiek`, będą obsługiwani przez `SlotMeta`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:56:19.191920900Z",
     "start_time": "2023-11-27T01:56:19.170438300Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Aktor(Człowiek):\n",
    "    def __init__(self, imię, nazwisko, znane_języki):\n",
    "        pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Zobaczmy, `Aktor` teraz ma atrybut `slots`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:56:23.051483600Z",
     "start_time": "2023-11-27T01:56:22.963244900Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['__class__',\n",
       " '__delattr__',\n",
       " '__dir__',\n",
       " '__doc__',\n",
       " '__eq__',\n",
       " '__format__',\n",
       " '__ge__',\n",
       " '__getattribute__',\n",
       " '__getstate__',\n",
       " '__gt__',\n",
       " '__hash__',\n",
       " '__init__',\n",
       " '__init_subclass__',\n",
       " '__le__',\n",
       " '__lt__',\n",
       " '__module__',\n",
       " '__ne__',\n",
       " '__new__',\n",
       " '__reduce__',\n",
       " '__reduce_ex__',\n",
       " '__repr__',\n",
       " '__setattr__',\n",
       " '__sizeof__',\n",
       " '__slots__',\n",
       " '__str__',\n",
       " '__subclasshook__',\n",
       " 'imię',\n",
       " 'nazwisko',\n",
       " 'znane_języki']"
      ]
     },
     "execution_count": 85,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dir(Aktor)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Możemy się do niego odwołać."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:56:27.321618200Z",
     "start_time": "2023-11-27T01:56:27.289668800Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "('imię', 'nazwisko', 'znane_języki')"
      ]
     },
     "execution_count": 86,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Aktor.__slots__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:56:30.004408900Z",
     "start_time": "2023-11-27T01:56:29.952510600Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": [
    "class Statysta:\n",
    "    def __init__(self, imię, nazwisko, znane_języki):\n",
    "        pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "Tymczasem `Statysta` nie dziedziczy po `Człowiek`, czyli ma standardową metaklasę i nie ma `slots`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:56:36.118387200Z",
     "start_time": "2023-11-27T01:56:36.088463700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['__class__',\n",
       " '__delattr__',\n",
       " '__dict__',\n",
       " '__dir__',\n",
       " '__doc__',\n",
       " '__eq__',\n",
       " '__format__',\n",
       " '__ge__',\n",
       " '__getattribute__',\n",
       " '__getstate__',\n",
       " '__gt__',\n",
       " '__hash__',\n",
       " '__init__',\n",
       " '__init_subclass__',\n",
       " '__le__',\n",
       " '__lt__',\n",
       " '__module__',\n",
       " '__ne__',\n",
       " '__new__',\n",
       " '__reduce__',\n",
       " '__reduce_ex__',\n",
       " '__repr__',\n",
       " '__setattr__',\n",
       " '__sizeof__',\n",
       " '__str__',\n",
       " '__subclasshook__',\n",
       " '__weakref__']"
      ]
     },
     "execution_count": 88,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dir(Statysta)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "I jeśli spróbujemy się do niego dostać, zobaczymy błąd."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2023-11-27T01:56:50.000559100Z",
     "start_time": "2023-11-27T01:56:49.927134700Z"
    },
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "type object 'Statysta' has no attribute '__slots__'",
     "output_type": "error",
     "traceback": [
      "\u001B[0;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[0;31mAttributeError\u001B[0m                            Traceback (most recent call last)",
      "Cell \u001B[0;32mIn[89], line 1\u001B[0m\n\u001B[0;32m----> 1\u001B[0m \u001B[43mStatysta\u001B[49m\u001B[38;5;241;43m.\u001B[39;49m\u001B[38;5;18;43m__slots__\u001B[39;49m\n",
      "\u001B[0;31mAttributeError\u001B[0m: type object 'Statysta' has no attribute '__slots__'"
     ]
    }
   ],
   "source": [
    "Statysta.__slots__"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": [
    "##### Podsumowując:\n",
    "Historycznie Metaklasy były używane do różnych zadań, które teraz są możliwe do zrealizowania za pomocą innych środków.\n",
    "W książce \"Efektywny Pyhon\", wszystkie sposoby dotyczące metaklas, podpowiadają jak ich nie stosować:\n",
    "- zamiast refaktoryzować atrybuty można użyć `@property`\n",
    "- stosuj deskryptory\n",
    "- wykorzystaj `__init_subclass__()`\n",
    "- adnotacje atrybutów klas dodawaj za pomocą `__set_name__()` (tego już nie zdążyliśmy omówić)\n",
    "- dla złożonych rozszerzeń klas wybieraj dekoratory klas zamiast metaklas (metaklas nie można łączyć ze sobą, a wiele dekoratorów klas można wykorzystać do rozszerzenia jednej klasy)\n",
    "\n",
    "Na szczęście nasz ostatni przykład ze `__slots__` nie da się rozwiązać używając dekoratorów klas, czy za pomocą `__init_subclass__()`, ponieważ te funkcje działają na klasie już po jej utworzeniu.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "jupyter": {
     "outputs_hidden": false
    }
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
